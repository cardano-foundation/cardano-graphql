scalar DateTime

type Block {
  id: ID!
  hash: String!
  merkleRootHash: String!
  number: Int!
  previousBlock: Block
  size: Float!
  slot: Slot!
  transactions: [Transaction]!
}

input BlockFilter {
  epoch: Int
  slot: Int
  afterHeight: Int
  beforeHeight: Int
}

type Epoch {
  blocks: [Block]!
  number: Int!
  slots: [Slot!]!
  transactions: [Transaction]
}

type Ledger {
  blockHeight: Int!
}

type Mempool {
  transaction(id: ID!): Transaction!
  transactions(id: ID!): [Transaction]!
  transactionCount: Int!
}

type Slot {
  block: Block
  epoch: Epoch!
}

type TransactionInput {
  sourceTxId: String!,
  sourceTxOutputIndex: Int!
  address: String!
  value: Int!
}

type TransactionOutput {
  value: Int!
  address: String!
}

type Transaction {
  fee: Float!
  hash: String!
  id: ID!
  inputs: [TransactionInput!]!
  outputs: [TransactionOutput!]!
}

input TransactionFilter {
  hashes: [String]
  addresses: [String]
  epoch: Int
  slot: Int
  inBlockNo: Int
  inBlockId: ID
  includedBefore: DateTime
  includedAfter: DateTime
}

type Query {
  block(id: ID!, filter: BlockFilter): Block
  blocks(ids: [String!], filter: BlockFilter): [Block!]!
  epoch(number: Int) : Epoch!
  epochs(numbers: [Int!]): [Epoch!]!
  transaction(hash: String!): Transaction
  transactions(hashes: [String!], filter: TransactionFilter): [Transaction]!
  utxo(address: String): [TransactionOutput]!
}
