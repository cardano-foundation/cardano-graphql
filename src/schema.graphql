schema {
  query: Query
}

scalar Hash32HexString
scalar BigInt
scalar DateTime
scalar Lovelaces
scalar Percentage

type Query {
  blocks (
    limit: Int
    order_by: [Block_order_by!]
    offset: Int
    where: Block_bool_exp
  ): [Block]!
  epochs (
    limit: Int
    order_by: [Epoch_order_by!]
    offset: Int
    where: Epoch_bool_exp
  ): [Epoch]!
  cardano: Cardano
  transactions (
    limit: Int
    order_by: [Transaction_order_by!]
    offset: Int
    where: Transaction_bool_exp
  ): [Transaction]!
  utxoSet (
    limit: Int
    order_by: [Utxo_order_by!]
    offset: Int
    where: Utxo_bool_exp!
  ): [TransactionOutput]!
}

type Cardano {
  blockHeight: Int!
  currentEpoch: Epoch!
}

type Transaction {
  block: Block
  fee: String!
  id: Hash32HexString!
  inputs: [TransactionInput!]!
  outputs: [TransactionOutput!]!
  totalOutput: String!
  includedAt: DateTime!
}

input Transaction_order_by {
  block: order_by
  fee: order_by
}

input Transaction_bool_exp {
  id: Hash32HexString_comparison_exp
  block: Block_bool_exp
}

type TransactionInput {
  sourceTxId: Hash32HexString!
  sourceTxIndex: Int!
  address: String!
  value: String!
}

type TransactionOutput {
  address: String!
  index: Int!
  txId: Hash32HexString!
  value: String!
}

type Block {
  epoch: Epoch
  fees: String
  id: Hash32HexString!
  merkelRootHash: Hash32HexString
  # Genesis and Epoch Boundary Blocks (EBBs) do not have numbers
  number: Int
  slotNo: Int
  slotWithinEpoch: Int
  previousBlock: Block
  size: Int!
  createdAt: DateTime!
  transactions(
    limit: Int
    order_by: [Transaction_order_by!]
    offset: Int
    where: Transaction_bool_exp
  ): [Transaction]!
  transactions_aggregate: Transaction_aggregate!
}

input Block_bool_exp {
  id: Hash32HexString_comparison_exp
  epoch: Epoch_bool_exp
  number: Int_comparison_exp
}

input Block_order_by {
  number: order_by
  size: order_by
}

type Transaction_aggregate {
  aggregate: Transaction_aggregate_fields
}

type Transaction_aggregate_fields {
  avg: Transaction_avg_fields
  count: Int
  max: Transaction_max_fields
  min: Transaction_min_fields
  sum: Transaction_sum_fields
}

type Transaction_avg_fields {
  fee: Float
  totalOutput: Float
}

type Transaction_max_fields {
  fee: BigInt
  totalOutput: BigInt
}

type Transaction_min_fields {
  fee: BigInt
  totalOutput: BigInt
}

type Transaction_sum_fields {
  fee: BigInt
  totalOutput: BigInt
}

type Epoch {
  blocks (
    limit: Int
    order_by: [Block_order_by!]
    offset: Int
    where: Block_bool_exp
  ): [Block]
  blocks_aggregate: Block_aggregate!
  output: String!
  number: Int!
  transactionsCount: String
  startedAt: DateTime!
  lastBlockTime: DateTime!
}

input Epoch_bool_exp {
  number: Int_comparison_exp
}

input Epoch_order_by {
  blockCount: order_by
  number: order_by
  fees: order_by
}

type Block_aggregate {
  aggregate: Block_aggregate_fields
}

type Block_aggregate_fields {
  avg: Block_avg_fields
  count: Int
  max: Block_max_fields
  min: Block_min_fields
  sum: Block_sum_fields
}

type Block_avg_fields {
  fees: Float
  size: Float
}

type Block_max_fields {
  fees: BigInt
  size: BigInt
}

type Block_min_fields {
  fees: BigInt
  size: BigInt
}


type Block_sum_fields {
  fees: BigInt
  size: BigInt
}

input Utxo_bool_exp {
  address: text_comparison_exp
}

input Utxo_order_by {
  address: order_by
}

# expression to compare data of type date. All fields are combined with logical 'AND'.
input Date_comparison_exp {
  _eq: DateTime
  _gt: DateTime
  _gte: DateTime
  _in: [DateTime]
  _lt: DateTime
  _lte: DateTime
  _neq: DateTime
  _nin: [DateTime]
}

# expression to compare data of type Int. All fields are combined with logical 'AND'.
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

# expression to compare data of type Lovelaces. All fields are combined with logical 'AND'.
input Lovelaces_comparison_exp {
  _eq: Lovelaces
  _gt: Lovelaces
  _gte: Lovelaces
  _in: [Lovelaces!]
  _lt: Lovelaces
  _lte: Lovelaces
  _neq: Lovelaces
  _nin: [Lovelaces!]
}

# expression to compare data of type Percentage. All fields are combined with logical 'AND'.
input Percentage_comparison_exp {
  _eq: Percentage
  _gt: Percentage
  _gte: Percentage
  _lt: Int
  _lte: Int
  _neq: Int
}

# All fields are combined with logical 'AND'.
input Hash32HexString_comparison_exp {
  _eq: Hash32HexString
  _in: [Hash32HexString]
  _neq: Hash32HexString
  _nin: [Hash32HexString]
}

input text_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String]
  _nlike: String
  _nsimilar: String
  _similar: String
}

# ordering options
enum order_by {
  # in the ascending order, nulls last
  asc
  # in the ascending order, nulls first
  desc
}

# ordering options
enum order_by_with_nulls {
  # in the ascending order, nulls last
  asc
  # in the ascending order, nulls first
  asc_nulls_first
  # in the ascending order, nulls last
  asc_nulls_last
  # in the descending order, nulls first
  desc
  # in the descending order, nulls first
  desc_nulls_first
  # in the descending order, nulls last
  desc_nulls_last
}
